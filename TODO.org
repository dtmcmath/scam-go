#+TITLE:  Things SCAM Should Do
#+AUTHOR: David McMath
#+EMAIL:  mcdave@mheducation.com
#+OPTIONS: ^:{} toc:nil
#+SEQ_TODO: TODO INPROGRESS(!) | DONE(!)

This document sketches, somewhat randomly, things that need to get
done to make SCAM a thing of true beauty.

#+TOC: headlines

* Issues

** Lex errors are very cryptic

** "*define*" evaluates to =()=

#+BEGIN_SRC scheme
(null? (define a 1))
#+END_SRC

really ought to be nonsense; *define* isn't actually a term.  It's a
macro, or something

** Plain-ol' atoms are assumed to be methods

In real Scheme:

#+BEGIN_SRC
$ chez
Chez Scheme Version 9.5
Copyright 1984-2017 Cisco Systems, Inc.

> (#t)
Exception: attempt to apply non-procedure #t
#+END_SRC

That's a much better answer than

#+BEGIN_SRC
$ go run scam.go
SCAM Version 0.1
Please be gentle

> (#t)
(#t)
#+END_SRC

* Desiderata

** Î»

I really want a keyword "*lambda*".  With that, we could define

#+BEGIN_SRC scheme
(define cons
  (lambda (a b)
    (lambda (c)
      (if (eq? c 'car)
          a
          (if (eq? c 'cdr)
              b
          )
      )
    )
  )
)
(define car (lambda (c) (c 'car)))
(define cdr (lambda (c) (c 'cdr)))
#+END_SRC

*** New expression type: function (and macro)

A function is something to which we can apply

#+BEGIN_SRC go
func apply_fn(f func_expr, args []Sexpr, ctx *evaluationContext) (Sexpr, sexpr_error) {
  newCtx := &evaluationContext{make(symbolTable), ctx}
  for idx, sym := f.bound {
    newCtx.bind(sym, evaluateWithContext(args[idx], ctx))
  }
  return evaluteWithContext(f.body, newCtx)
}
#+END_SRC

A macro (operator?) is similar but more complicated.  Each macro needs
its own evaluator, because they all have funky rules.  =define=,
=lambda=, =let=, =or=, =+=, and =quote= are all examples of macros.
There are more.

*** Simplify evaluate

#+BEGIN_SRC go
func evaluateWithContext(s Sexpr, ctx *evaluationContext) (Sexpr, sexpr_error) {
	switch s := s.(type) {
	case sexpr_atom: return s.evaluate(ctx)
	case sexpr_cons:
		car, err := evaluateWithContext(s.car, ctx)
		if err != nil {
			return nil, err
		}
		switch car := car.(type) {
		case func_expr: return apply_fn(car, unconsify(s.cdr), ctx)
                case macro_expr: return car.apply(s.cdr, ctx)
                defult:
                        return nil, evaluationError{... non function ...}
                }
...
#+ENV_SRC

*** Notation for primitive symbols

It'll be good to have a way to tell whether a symbol can be re-bound
or not.

#+BEGIN_SRC scheme
(define null? (lambda (x) (eq? x 'not_null)))
#+END_SRC

is funny and all but confusing.

** INPROGRESS Separate parse errors from evaluation errors

I need to read more about what an "error" S-expression looks like.
Right now, they just look like pretty generic Go structs.

The evaluator's errors look quite a lot like those from
[[https://cisco.github.io/ChezScheme/][Chez Scheme]] (because I copied them).  Parse errors are still a mess

** Bignums

Don't you wonder what

#+BEGIN_SRC scheme
(+ 3141592653589793238462643383279502884197169399375105820974944592307
   2718281828459045235360287471352662497757247093699959574966967627724)
#+END_SRC

is?

** Implement (more) keywords

- *begin*
- *pair?*
- *lambda*

So that we can retire

- *atom?*
- ...

* Roadmap

This section tries to put some of the developments into a sequence.

** Cons-es recycled
