#+TITLE:  Things SCAM Should Do
#+AUTHOR: David McMath
#+EMAIL:  mcdave@mheducation.com
#+OPTIONS: ^:{} toc:nil
#+SEQ_TODO: TODO INPROGRESS(!) | DONE(!)

This document sketches, somewhat randomly, things that need to get
done to make SCAM a thing of true beauty.

#+TOC: headlines

* Issues

** Lex errors are very cryptic

** Quote is misplaced (by parser) for lists

Consider

#+BEGIN_SRC scheme
(define a 1)
(define b 2)
(cons a b)   ; evaluates to (1 . 2), correctly
'(a b)       ; evaluates to (a 2), incorrectly
#+END_SRC

The reason ='(a b)= is wrong is that the parser is converting it to

#+BEGIN_SRC scheme
(cons (quote a) (cons b ()))
#+END_SRC

as demonstrated by the following session:

#+BEGIN_SRC
> '(a b)
2018/01/01 23:36:15 Evaluating a generic 'cons': "Cons(Cons(Sym(quote), Cons(Sym(a), Nil)), Cons(Sym(b), Nil))"
Exception in lookup: Variable Sym(b) is not bound
#+END_SRC

There's a (red) test for that in
[[./sexpr/evaluator_test.go][evaluator_test, TestEvaluateEqQ]], so this seems tractable.

* Desiderata

** Î»

I really want a keyword "*lambda*".  With that, we could define

#+BEGIN_SRC scheme
(define cons
  (lambda (a b)
    (lambda (c)
      (if (eq? c 'car)
          a
          (if (eq? c 'cdr)
              b
          )
      )
    )
  )
)
(define car (lambda (c) (c 'car)))
(define cdr (lambda (c) (c 'cdr)))
#+END_SRC

** INPROGRESS Separate parse errors from evaluation errors

I need to read more about what an "error" S-expression looks like.
Right now, they just look like pretty generic Go structs.

The evaluator's errors look quite a lot like those from
[[https://cisco.github.io/ChezScheme/][Chez Scheme]] (because I copied them).  Parse errors are still a mess

** Bignums

Don't you wonder what

#+BEGIN_SRC scheme
(+ 3141592653589793238462643383279502884197169399375105820974944592307
   2718281828459045235360287471352662497757247093699959574966967627724)
#+END_SRC

is?

* Roadmap

This section tries to put some of the developments into a sequence.

** Cons-es recycled
